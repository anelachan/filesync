Detailed explanation of filesync

The Server listens for connections over a socket. The Client requests to make a connection and the Server creates a new stream socket for that Client. The Client sends an initialization vector to the Server specifying mode and block size. As a default, the Client is in “push” mode meaning that it is the source, sending files to the destination (here, Server). The Client then executes two threads in parallel: one, it begins to service the Instruction queue of its file to synchronize in a PushThread. Two, it continues to fill the queue via an InstructionFiller (which checks the File state and creates instructions). Meanwhile, the Server executes a Pull Thread, which processes the Instruction queue of its own file to synchronize. 

Basic Flow of Events: The main protocol of message passing for synchronization actually occurs between the PushThread and the PullThread, which provide a level of abstraction so that the protocol can be reversed if needed (as described later). In the default condition the protocol uses two kinds of messages: Instructions and Acknowledgements. Instructions have at least one field, Type, which could be StartUpdate, CopyBlock, NewBlock or EndUpdate. Instructions of type CopyBlock and NewBlock have additional fields, including offset, length and hash. The “pusher” signals the start of an update by sending an Instruction of type StartUpdate. The “pusher” could then send any combination and number of CopyBlock and NewBlock Instructions. Finally, the “pusher” sends an EndUpdate. The actual bytes to copy or send are specified in the offset, length and hash fields, which mean offset into the file, the length of the bytes and the actual bytes to copy or “insert” (in case of NewBlock, when the source file has changed) into the document.

In this protocol, each of these messages must be acknowledged positively or negatively by the “puller”. The “pusher” will not send the next instruction unless it has received a positive acknowledgement. The Acknowledgements are another type of message with one field: “ack”, which has values “Received and processed.” or “Need new block!” (Succinct boolean values could be used as well.) The “puller” generates these values when it processes each instruction. The “pusher” must then process the acknowledgements in order to proceed.

BlockUnavailableException: If the “pusher” sends a CopyBlockInstruction and upon processing it and the “puller” finds that piece of data is not in its destination file, the processing method will throw a BlockUnavailableException. In this case instead of a “Received and processed.” acknowledgement the “puller” sends the message “Need new block!”. The “pusher” upon processing it will also have its processing method throw a BlockUnavailableException. Now instead of proceeding it will upgrade the previously sent CopyBlockInstruction to a NewBlockInstruction and send this to the “puller.” This is acknowledged and the whole protocol proceeds as usual. 

Using Optional Parameters in the Protocol: The Client has the option to specify a direction and a block size. Direction can be push or pull, meaning the client can either push to the server as destination or pull from the server as source. Block size is the number of blocks to be sent at a time for file synchronization. These are given as optional command-line arguments, but in fact the Client will always initialize with “mode” 
(direction) and “blocksize” variables; if not specified they default to “push” and 1024, respectively.

This setting of synchronization parameters is achieved with an additional message passed between Client and Server before the synchronization begins. This type of message has two fields: “mode” and “blocksize”, which correspond to the values described above. After the stream socket is created the client sends the initialization vector over the stream with the parameters specified. If the mode is “push” (which is also default) the protocol proceeds as described earlier (see Figure 1). If the mode is “pull” then the Server runs the PushThread and InstructionFiller, while the Client runs the PushThread, which is depicted in Figure 4.